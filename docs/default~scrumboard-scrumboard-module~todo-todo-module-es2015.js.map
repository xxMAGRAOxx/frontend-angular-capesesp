{"version":3,"sources":["./node_modules/@swimlane/ngx-dnd/__ivy_ngcc__/fesm2015/swimlane-ngx-dnd.js","./node_modules/contra/emitter.js","./node_modules/atoa/atoa.js","./node_modules/ticky/ticky-browser.js","./node_modules/@swimlane/dragula/dragula.js","./node_modules/contra/debounce.js","./node_modules/crossvent/src/crossvent.js","./node_modules/crossvent/src/eventmap.js","./node_modules/custom-event/index.js","./node_modules/@swimlane/dragula/classes.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuO;AACxL;AACO;;AAEtD;AACwC;AACE;;AAE1C,6EAA6E;AAC7E,IAAI,qEAA8B;AAClC,IAAI,uDAAgB;AACpB,IAAI,mEAA4B;AAChC,CAAC;AACD;AACA,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,CAAC;AACD,8DAA8D;AAC9D,IAAI,qEAA8B;AAClC,IAAI,wDAAiB;AACrB,IAAI,mEAA4B;AAChC,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,CAAC;AACD,4DAA4D;AAC5D,IAAI,0DAAmB;AACvB,CAAC;AACD,2BAA2B,SAAS,kBAAkB;AACtD;AACA,yDAAyD;AACzD,IAAI,qEAA8B;AAClC,IAAI,uDAAgB;AACpB,IAAI,mEAA4B;AAChC,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,CAAC;AACD,yEAAyE;AACzE,2DAA2D;AAC3D,IAAI,wDAAiB;AACrB,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,CAAC;AACD,4FAA4F;AAC5F,IAAI,uDAAgB;AACpB,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,CAAC;AACD,wEAAwE;AACxE,IAAI,qEAA8B;AAClC,IAAI,4DAAqB;AACzB,IAAI,oDAAa;AACjB,IAAI,0DAAmB;AACvB,IAAI,wDAAiB;AACrB,IAAI,mEAA4B;AAChC,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,gEAAyB;AAC7B,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,CAAC;AACD,yDAAyD;AACzD,IAAI,qEAA8B;AAClC,IAAI,wDAAiB;AACrB,IAAI,wDAAiB;AACrB,IAAI,mEAA4B;AAChC,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,CAAC;AACD,yDAAyD;AACzD,IAAI,gEAAyB;AAC7B,CAAC;AACD,yEAAyE;AACzE,2DAA2D;AAC3D,IAAI,wDAAiB;AACrB,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,CAAC;AACD,+DAA+D;AAC/D,IAAI,4DAAqB;AACzB,IAAI,oDAAa;AACjB,IAAI,0DAAmB;AACvB,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,gEAAyB;AAC7B,CAAC;AACD,yDAAyD;AACzD,IAAI,qEAA8B;AAClC,IAAI,wDAAiB;AACrB,IAAI,wDAAiB;AACrB,IAAI,mEAA4B;AAChC,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,IAAI,uDAAgB;AACpB,IAAI,wDAAiB;AACrB,CAAC;AACD,gBAAgB,8CAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,gEAAgE,uCAAuC;AACvG,0BAA0B,wEAAkB,EAAE,gDAAgD,gCAAgC,EAAE,gDAAgD;AAChL;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,gBAAgB,qBAAqB;AACrC,KAAK,gBAAgB,WAAW,EAAE,QAAQ,EAAE;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAY;AACpC,wBAAwB,0DAAY;AACpC,wBAAwB,0DAAY;AACpC,uBAAuB,0DAAY;AACnC,0BAA0B,0DAAY;AACtC,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kEAAkE,sCAAsC,+DAAwB,CAAC,wDAAiB,GAAG,+DAAwB,CAAC,uDAAgB,GAAG,+DAAwB,qBAAqB;AAC9O,0BAA0B,+DAAwB,EAAE,2EAA2E,2IAA2I,YAAY,2FAA2F,EAAE;AACnX;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,uDAAS,EAAE;AACvB,KAAK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AyB;AAC5D,+BAA+B,0BAA0B;AACzD,8CAA8C,mCAAmC;AACjF,qCAAqC,8BAA8B;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,qBAAqB;AACrB,OAAO;AACP,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAkD;AAC7E,sBAAsB,eAAe,eAAe,EAAE;AACtD,qBAAqB,uBAAuB,cAAc,EAAE;AAC5D;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,4BAA4B;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA,6DAA6D,WAAW;AACxE,wEAAwE,WAAW;AACnF,oFAAoF,WAAW;AAC/F;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,yBAAyB;AACtD,4CAA4C,gBAAgB,EAAE;AAC9D,6BAA6B,kBAAkB;AAC/C;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC,oBAAoB,aAAa;AACjC,8BAA8B,+CAA+C;AAC7E,+BAA+B,gDAAgD;AAC/E,yBAAyB,qDAAqD;AAC9E,uBAAuB,yGAAyG;AAChI;AACA,YAAY,cAAc,EAAE;AAC5B,uCAAuC,cAAc,EAAE;AACvD,sCAAsC,aAAa,EAAE;AACrD,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjmBa;;AAEb,YAAY,mBAAO,CAAC,mBAAO;;AAE3B;AACA,YAAY,QAAQ;AACpB;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACTa;;AAEb,kBAAkB,mBAAO,CAAC,0BAAc;AACxC,eAAe,mBAAO,CAAC,wBAAY;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAuE,uBAAuB;AAC9F,0EAA0E,uBAAuB;AACjG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACXA;;AAEA;AACA;AACA,0CAA0C,UAAU,aAAa,EAAE;AACnE;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ca;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"default~scrumboard-scrumboard-module~todo-todo-module-es2015.js","sourcesContent":["import { ɵɵdefineInjectable, Injectable, EventEmitter, Directive, ElementRef, Renderer2, Input, Output, HostListener, Component, ViewEncapsulation, ContentChild, TemplateRef, ViewChild, HostBinding, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport * as dragulaNamespace from '@swimlane/dragula';\n\n// see https://github.com/dherges/ng-packagr/issues/217\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction ContainerComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelement(1, \"ngx-dnd-item\", 3);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const item_r3 = ctx.$implicit;\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"model\", item_r3)(\"dropZone\", ctx_r2.dropZone)(\"dropZones\", ctx_r2.dropZones)(\"copy\", ctx_r2.copy)(\"moves\", ctx_r2.moves)(\"removeOnSpill\", ctx_r2.removeOnSpill)(\"droppableItemClass\", ctx_r2.droppableItemClass);\n} }\nfunction ContainerComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, ContainerComponent_ng_container_1_ng_container_1_Template, 2, 7, \"ng-container\", 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.model);\n} }\nfunction ContainerComponent_ng_content_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0, 0, [\"*ngIf\", \"!model\"]);\n} }\nconst _c0 = function (a0) { return { \"gu-empty\": a0 }; };\nconst _c1 = [\"*\"];\nfunction ItemComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelement(1, \"ngx-dnd-container\", 3);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"model\", ctx_r0.model)(\"template\", ctx_r0.container.template)(\"dropZone\", ctx_r0.dropZone)(\"dropZones\", ctx_r0.dropZones)(\"removeOnSpill\", ctx_r0.removeOnSpill)(\"droppableItemClass\", ctx_r0.droppableItemClass)(\"copy\", ctx_r0.copy);\n} }\nfunction ItemComponent_ng_container_2_1_ng_template_0_Template(rf, ctx) { }\nfunction ItemComponent_ng_container_2_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_container_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n} if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.container.template)(\"ngTemplateOutletContext\", ctx_r4.data);\n} }\nfunction ItemComponent_ng_container_2_ng_container_2_ngx_dnd_container_3_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ngx-dnd-container\", 3);\n} if (rf & 2) {\n    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"model\", ctx_r7.model.children)(\"template\", ctx_r7.container.template)(\"dropZone\", ctx_r7.dropZone)(\"dropZones\", ctx_r7.dropZones)(\"removeOnSpill\", ctx_r7.removeOnSpill)(\"droppableItemClass\", ctx_r7.droppableItemClass)(\"copy\", ctx_r7.copy);\n} }\nfunction ItemComponent_ng_container_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 6);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(3, ItemComponent_ng_container_2_ng_container_2_ngx_dnd_container_3_Template, 1, 7, \"ngx-dnd-container\", 7);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r5.model.label, \" \");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.model.children);\n} }\nfunction ItemComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_container_2_1_Template, 1, 2, undefined, 4);\n    ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_container_2_ng_container_2_Template, 4, 2, \"ng-container\", 4);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.container.template);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.container.template);\n} }\nfunction ItemComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n} }\nfunction ItemComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) { }\nfunction ItemComponent_ng_container_4_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_container_4_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n} if (rf & 2) {\n    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.container.template)(\"ngTemplateOutletContext\", ctx_r8.data);\n} }\nfunction ItemComponent_ng_container_4_div_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 6);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r9.model, \" \");\n} }\nfunction ItemComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_container_4_1_Template, 1, 2, undefined, 4);\n    ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_container_4_div_2_Template, 2, 1, \"div\", 8);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r3.container.template);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r3.container.template);\n} }\nconst dragula = dragulaNamespace;\n/**\n * Central service that handles all events\n *\n * @export\n */\nclass DrakeStoreService {\n    constructor() {\n        this.droppableMap = new WeakMap();\n        this.draggableMap = new WeakMap();\n        this.dragulaOptions = this.createDrakeOptions();\n        this.drake = dragula([], this.dragulaOptions);\n        this.registerEvents();\n    }\n    register(droppable) {\n        this.droppableMap.set(droppable.container, droppable);\n        this.drake.containers.push(droppable.container);\n    }\n    remove(droppable) {\n        this.droppableMap.delete(droppable.container);\n        const idx = this.drake.containers.indexOf(droppable.container);\n        if (idx > -1) {\n            this.drake.containers.splice(idx, 1);\n        }\n    }\n    registerDraggable(draggable) {\n        this.draggableMap.set(draggable.element, draggable);\n    }\n    removeDraggable(draggable) {\n        this.draggableMap.delete(draggable.element);\n    }\n    createDrakeOptions() {\n        const accepts = (el, target /*, source: any, sibling: any */) => {\n            if (el.contains(target)) {\n                return false;\n            }\n            const elementComponent = this.draggableMap.get(el);\n            const targetComponent = this.droppableMap.get(target);\n            if (elementComponent && targetComponent) {\n                return elementComponent.dropZones.includes(targetComponent.dropZone);\n            }\n            return true;\n        };\n        const copy = (_, source) => {\n            const sourceComponent = this.droppableMap.get(source);\n            if (sourceComponent) {\n                return sourceComponent.copy;\n            }\n            return false;\n        };\n        const moves = (el, source, handle, sibling) => {\n            const elementComponent = this.draggableMap.get(el);\n            if (elementComponent) {\n                return elementComponent.moves(source, handle, sibling);\n            }\n            return true;\n        };\n        const direction = (el, target, source) => {\n            const targetComponent = this.droppableMap.get(target);\n            return targetComponent.direction || 'vertical';\n        };\n        return { accepts, copy, moves, revertOnSpill: true, direction };\n    }\n    registerEvents() {\n        let dragElm;\n        let draggedItem;\n        this.drake.on('drag', (el, source) => {\n            draggedItem = undefined;\n            dragElm = el;\n            if (!el || !source) {\n                return;\n            }\n            if (this.draggableMap.has(el)) {\n                const elementComponent = this.draggableMap.get(el);\n                draggedItem = elementComponent.model;\n                elementComponent.drag.emit({\n                    type: 'drag',\n                    el,\n                    source,\n                    value: draggedItem\n                });\n            }\n            if (this.droppableMap.has(source)) {\n                const sourceComponent = this.droppableMap.get(source);\n                this.dragulaOptions.removeOnSpill = sourceComponent.removeOnSpill;\n                sourceComponent.drag.emit({\n                    type: 'drag',\n                    el,\n                    source,\n                    sourceComponent,\n                    value: draggedItem\n                });\n            }\n        });\n        this.drake.on('drop', (el, target, source) => {\n            const targetComponent = this.droppableMap.get(target);\n            if (!targetComponent) {\n                // not a target, abort\n                return;\n            }\n            let dropElmModel = draggedItem;\n            const dropIndex = Array.prototype.indexOf.call(target.children, el);\n            if (dropIndex < 0) {\n                // dropIndex is bad... cancel\n                this.drake.cancel(true);\n                return;\n            }\n            const sourceComponent = this.droppableMap.get(source);\n            if (sourceComponent) {\n                const sourceModel = sourceComponent.model;\n                const targetModel = targetComponent.model;\n                const hasDragModel = !!(sourceModel && draggedItem);\n                const dragIndex = hasDragModel ? sourceModel.indexOf(draggedItem) : -1;\n                if (hasDragModel && dragIndex < 0) {\n                    // dragIndex is bad... cancel\n                    this.drake.cancel(true);\n                    return;\n                }\n                if (targetModel) {\n                    const reorder = dragIndex > -1 && sourceModel && target === source;\n                    const copy = !sourceModel || dragElm !== el;\n                    if (reorder) {\n                        sourceModel.splice(dropIndex, 0, sourceModel.splice(dragIndex, 1)[0]);\n                    }\n                    else {\n                        if (el.parentNode === target) {\n                            target.removeChild(el);\n                        }\n                        if (copy) {\n                            dropElmModel = JSON.parse(JSON.stringify(dropElmModel));\n                        }\n                        else {\n                            if (el.parentNode !== source) {\n                                // add element back, let angular remove it\n                                this.drake.cancel(true);\n                            }\n                            sourceModel.splice(dragIndex, 1);\n                        }\n                        targetModel.splice(dropIndex, 0, dropElmModel);\n                    }\n                }\n            }\n            targetComponent.drop.emit({\n                type: 'drop',\n                el,\n                source,\n                value: dropElmModel,\n                dropIndex\n            });\n        });\n        this.drake.on('remove', (el, container, source) => {\n            if (this.droppableMap.has(source)) {\n                const sourceComponent = this.droppableMap.get(source);\n                const sourceModel = sourceComponent.model;\n                const dragIndex = draggedItem && sourceModel ? sourceModel.indexOf(draggedItem) : -1;\n                if (dragIndex > -1) {\n                    if (el.parentNode !== source) {\n                        // add element back, let angular remove it\n                        source.appendChild(el);\n                    }\n                    sourceModel.splice(dragIndex, 1);\n                }\n                sourceComponent.remove.emit({\n                    type: 'remove',\n                    el,\n                    container,\n                    source,\n                    value: draggedItem\n                });\n            }\n        });\n        this.drake.on('cancel', (el, container, source) => {\n            if (this.droppableMap.has(container)) {\n                const containerComponent = this.droppableMap.get(container);\n                containerComponent.cancel.emit({\n                    type: 'cancel',\n                    el,\n                    container,\n                    source,\n                    value: draggedItem\n                });\n            }\n        });\n        this.drake.on('over', (el, container, source) => {\n            if (this.droppableMap.has(container)) {\n                const containerComponent = this.droppableMap.get(container);\n                containerComponent.over.emit({\n                    type: 'over',\n                    el,\n                    container,\n                    source,\n                    value: draggedItem\n                });\n            }\n        });\n        this.drake.on('out', (el, container, source) => {\n            if (this.droppableMap.has(container)) {\n                const containerComponent = this.droppableMap.get(container);\n                containerComponent.out.emit({\n                    type: 'out',\n                    el,\n                    container,\n                    source,\n                    value: draggedItem\n                });\n            }\n        });\n    }\n}\nDrakeStoreService.ɵfac = function DrakeStoreService_Factory(t) { return new (t || DrakeStoreService)(); };\nDrakeStoreService.ɵprov = ɵɵdefineInjectable({ factory: function DrakeStoreService_Factory() { return new DrakeStoreService(); }, token: DrakeStoreService, providedIn: \"root\" });\nDrakeStoreService.ctorParameters = () => [];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrakeStoreService, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return []; }, null); })();\n\nlet i = 10000;\nfunction getNextId() {\n    return i++;\n}\n/**\n * Makes the container droppable and children draggable.\n *\n * @export\n */\nclass DroppableDirective {\n    constructor(el, renderer, drakesService) {\n        this.el = el;\n        this.renderer = renderer;\n        this.drakesService = drakesService;\n        this.copy = false;\n        this.removeOnSpill = false;\n        this.direction = 'vertical';\n        this.drop = new EventEmitter();\n        this.drag = new EventEmitter();\n        this.over = new EventEmitter();\n        this.out = new EventEmitter();\n        this.remove = new EventEmitter();\n        this.cancel = new EventEmitter();\n    }\n    get container() {\n        return this.el.nativeElement;\n    }\n    get dropZone() {\n        return this._dropZone || this.ngxDroppable || this.defaultZone;\n    }\n    set dropZone(val) {\n        this._dropZone = val;\n    }\n    ngOnInit() {\n        this.defaultZone = `@@DefaultDropZone-${getNextId()}@@`;\n        this.drakesService.register(this);\n    }\n    ngAfterViewInit() {\n        this.over.subscribe(() => {\n            this.renderer.addClass(this.container, 'gu-over');\n        });\n        this.out.subscribe(() => {\n            this.renderer.removeClass(this.container, 'gu-over');\n        });\n    }\n    ngOnDestroy() {\n        this.drakesService.remove(this);\n    }\n}\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) { return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DrakeStoreService)); };\nDroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DroppableDirective, selectors: [[\"\", \"ngxDroppable\", \"\"]], inputs: { copy: \"copy\", removeOnSpill: \"removeOnSpill\", direction: \"direction\", dropZone: \"dropZone\", model: \"model\", ngxDroppable: \"ngxDroppable\" }, outputs: { drop: \"drop\", drag: \"drag\", over: \"over\", out: \"out\", remove: \"remove\", cancel: \"cancel\" } });\nDroppableDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DrakeStoreService }\n];\nDroppableDirective.propDecorators = {\n    model: [{ type: Input }],\n    copy: [{ type: Input }],\n    removeOnSpill: [{ type: Input }],\n    ngxDroppable: [{ type: Input }],\n    direction: [{ type: Input }],\n    drop: [{ type: Output }],\n    drag: [{ type: Output }],\n    over: [{ type: Output }],\n    out: [{ type: Output }],\n    remove: [{ type: Output }],\n    cancel: [{ type: Output }],\n    dropZone: [{ type: Input }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n        type: Directive,\n        args: [{ selector: '[ngxDroppable]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DrakeStoreService }]; }, { copy: [{\n            type: Input\n        }], removeOnSpill: [{\n            type: Input\n        }], direction: [{\n            type: Input\n        }], drop: [{\n            type: Output\n        }], drag: [{\n            type: Output\n        }], over: [{\n            type: Output\n        }], out: [{\n            type: Output\n        }], remove: [{\n            type: Output\n        }], cancel: [{\n            type: Output\n        }], dropZone: [{\n            type: Input\n        }], model: [{\n            type: Input\n        }], ngxDroppable: [{\n            type: Input\n        }] }); })();\n\n/**\n * Adds properties and events to draggable elements\n *\n * @export\n */\nclass DraggableDirective {\n    constructor(el, drakesService, droppableDirective) {\n        this.el = el;\n        this.drakesService = drakesService;\n        this.droppableDirective = droppableDirective;\n        this._moves = true;\n        /*\n        ContentChildren doesn't get children created with NgTemplateOutlet\n        See https://github.com/angular/angular/issues/14842\n        Implemented via updateElements method\n      \n        @ContentChildren(DragHandleDirective, {descendants: true})\n        handlesList: QueryList<DragHandleDirective>; */\n        this.handles = [];\n        this.drag = new EventEmitter();\n        this.dragDelay = 200; // milliseconds\n        this.dragDelayed = true;\n    }\n    get dropZones() {\n        return this._dropZones || this.ngxDraggable || this._parentDropzones;\n    }\n    set dropZones(val) {\n        this._dropZones = val;\n    }\n    get hasHandle() {\n        return !!this.handles.length;\n    }\n    get element() {\n        return this.el.nativeElement;\n    }\n    // From: https://github.com/bevacqua/dragula/issues/289#issuecomment-277143172\n    onMove(e) {\n        if (!this._moves || this.dragDelayed) {\n            e.stopPropagation();\n            clearTimeout(this.touchTimeout);\n        }\n    }\n    onDown() {\n        if (this._moves) {\n            this.touchTimeout = setTimeout(() => {\n                this.dragDelayed = false;\n            }, this.dragDelay);\n        }\n    }\n    onUp() {\n        if (this._moves) {\n            clearTimeout(this.touchTimeout);\n            this.dragDelayed = true;\n        }\n    }\n    ngOnInit() {\n        this.update();\n    }\n    update() {\n        this._parentDropzones = [this.droppableDirective.dropZone];\n        this.drakesService.registerDraggable(this);\n        this.updateElements();\n    }\n    ngOnDestroy() {\n        this.drakesService.removeDraggable(this);\n    }\n    updateElements() {\n        const nativeElement = this.el.nativeElement;\n        const handles = nativeElement.querySelectorAll('[ngxdraghandle]');\n        this.handles = Array.from(handles).filter((h) => findFirstDraggableParent(h) === nativeElement);\n        function findFirstDraggableParent(c) {\n            while (c.parentNode) {\n                c = c.parentNode;\n                if (c.hasAttribute && c.hasAttribute('ngxdraggable')) {\n                    return c;\n                }\n            }\n        }\n    }\n    canMove(source, handle, sibling) {\n        if (typeof this._moves === 'boolean')\n            return this._moves;\n        if (typeof this._moves === 'function')\n            return this._moves(this.model, source, handle, sibling);\n        return true;\n    }\n    moves(source, handle, sibling) {\n        if (!this.canMove(source, handle, sibling))\n            return false;\n        return this.hasHandle ? this.handles.some(h => handelFor(handle, h)) : true;\n        function handelFor(c, p) {\n            if (c === p)\n                return true;\n            while ((c = c.parentNode) && c !== p)\n                ; // tslint:disable-line\n            return !!c;\n        }\n    }\n    ngDoCheck() {\n        this.updateElements();\n    }\n}\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DrakeStoreService), ɵngcc0.ɵɵdirectiveInject(DroppableDirective)); };\nDraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [[\"\", \"ngxDraggable\", \"\"]], hostBindings: function DraggableDirective_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"touchmove\", function DraggableDirective_touchmove_HostBindingHandler($event) { return ctx.onMove($event); })(\"touchstart\", function DraggableDirective_touchstart_HostBindingHandler() { return ctx.onDown(); })(\"touchend\", function DraggableDirective_touchend_HostBindingHandler() { return ctx.onUp(); });\n    } }, inputs: { _moves: [\"moves\", \"_moves\"], dropZones: \"dropZones\", ngxDraggable: \"ngxDraggable\", model: \"model\" }, outputs: { drag: \"drag\" } });\nDraggableDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DrakeStoreService },\n    { type: DroppableDirective }\n];\nDraggableDirective.propDecorators = {\n    ngxDraggable: [{ type: Input }],\n    model: [{ type: Input }],\n    dropZones: [{ type: Input }],\n    _moves: [{ type: Input, args: ['moves',] }],\n    drag: [{ type: Output }],\n    onMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],\n    onDown: [{ type: HostListener, args: ['touchstart',] }],\n    onUp: [{ type: HostListener, args: ['touchend',] }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n        type: Directive,\n        args: [{ selector: '[ngxDraggable]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DrakeStoreService }, { type: DroppableDirective }]; }, { _moves: [{\n            type: Input,\n            args: ['moves']\n        }], drag: [{\n            type: Output\n        }], dropZones: [{\n            type: Input\n        }], \n    // From: https://github.com/bevacqua/dragula/issues/289#issuecomment-277143172\n    onMove: [{\n            type: HostListener,\n            args: ['touchmove', ['$event']]\n        }], onDown: [{\n            type: HostListener,\n            args: ['touchstart']\n        }], onUp: [{\n            type: HostListener,\n            args: ['touchend']\n        }], ngxDraggable: [{\n            type: Input\n        }], model: [{\n            type: Input\n        }] }); })();\n\n/**\n * Adds properties and events to drag handle elements\n *\n * @export\n */\nclass DragHandleDirective {\n}\nDragHandleDirective.ɵfac = function DragHandleDirective_Factory(t) { return new (t || DragHandleDirective)(); };\nDragHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DragHandleDirective, selectors: [[\"\", \"ngxDragHandle\", \"\"]] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragHandleDirective, [{\n        type: Directive,\n        args: [{ selector: '[ngxDragHandle]' }]\n    }], null, null); })();\n\nlet i$1 = 0;\nfunction getNextId$1() {\n    return i$1++;\n}\n/**\n * Component that allows nested ngxDroppable and ngxDraggables\n *\n * @export\n */\nclass ContainerComponent {\n    constructor() {\n        this.copy = false;\n        this.removeOnSpill = false;\n        this.dropZone = `@@DefaultDropZone-${getNextId$1()}@@`;\n        this.drop = new EventEmitter();\n        this.drag = new EventEmitter();\n        this.over = new EventEmitter();\n        this.out = new EventEmitter();\n        this.remove = new EventEmitter();\n        this.cancel = new EventEmitter();\n    }\n    get dropZones() {\n        return this._dropZones || this._defaultZones;\n    }\n    set dropZones(val) {\n        this._dropZones = val;\n    }\n    // @Input() classes: any = {};\n    // @Input() dragulaOptions: any;\n    set templateInput(template) {\n        this.template = template;\n    }\n    set templateChild(template) {\n        this.template = template;\n    }\n    ngOnInit() {\n        this._defaultZones = [this.dropZone];\n    }\n    ngAfterViewInit() {\n        this.droppable.drag.subscribe((v) => this.drag.emit(v));\n        this.droppable.drop.subscribe((v) => this.drop.emit(v));\n        this.droppable.over.subscribe((v) => this.over.emit(v));\n        this.droppable.out.subscribe((v) => this.out.emit(v));\n        this.droppable.remove.subscribe((v) => this.remove.emit(v));\n        this.droppable.cancel.subscribe((v) => this.cancel.emit(v));\n    }\n}\nContainerComponent.ɵfac = function ContainerComponent_Factory(t) { return new (t || ContainerComponent)(); };\nContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContainerComponent, selectors: [[\"ngx-dnd-container\"]], contentQueries: function ContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n        ɵngcc0.ɵɵstaticContentQuery(dirIndex, TemplateRef, true);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateChild = _t.first);\n    } }, viewQuery: function ContainerComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵstaticViewQuery(DroppableDirective, true);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.droppable = _t.first);\n    } }, inputs: { copy: \"copy\", removeOnSpill: \"removeOnSpill\", dropZone: \"dropZone\", dropZones: \"dropZones\", templateInput: [\"template\", \"templateInput\"], model: \"model\", droppableItemClass: \"droppableItemClass\", moves: \"moves\" }, outputs: { drop: \"drop\", drag: \"drag\", over: \"over\", out: \"out\", remove: \"remove\", cancel: \"cancel\" }, ngContentSelectors: _c1, decls: 3, vars: 9, consts: [[\"ngxDroppable\", \"\", 1, \"ngx-dnd-container\", 3, \"dropZone\", \"model\", \"copy\", \"ngClass\", \"removeOnSpill\"], [4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"ngxDraggable\", \"\", 3, \"model\", \"dropZone\", \"dropZones\", \"copy\", \"moves\", \"removeOnSpill\", \"droppableItemClass\"]], template: function ContainerComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, ContainerComponent_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n        ɵngcc0.ɵɵtemplate(2, ContainerComponent_ng_content_2_Template, 1, 0, \"ng-content\", 1);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"dropZone\", ctx.dropZone)(\"model\", ctx.model)(\"copy\", ctx.copy)(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c0, !(ctx.model == null ? null : ctx.model.length)))(\"removeOnSpill\", ctx.removeOnSpill);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.model);\n    } }, directives: function () { return [DroppableDirective, ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgForOf, ItemComponent, DraggableDirective]; }, styles: [\".ngx-dnd-container{background-color:hsla(0,0%,100%,.2);border:2px solid red;margin:10px;padding:10px}.ngx-dnd-container.gu-empty{border:2px dotted red}.ngx-dnd-container:nth-child(odd){background-color:rgba(0,0,0,.2)}.ngx-dnd-container .ex-moved{background-color:#e74c3c}.ngx-dnd-container .ex-over{background-color:hsla(0,0%,100%,.3)}.ngx-dnd-container .handle{background-color:rgba(0,0,0,.4);cursor:move;margin-right:5px;padding:0 5px}.no-select{-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.clearfix:after{clear:both;content:\\\" \\\";display:block;height:0}\"], encapsulation: 2 });\nContainerComponent.propDecorators = {\n    model: [{ type: Input }],\n    copy: [{ type: Input }],\n    removeOnSpill: [{ type: Input }],\n    droppableItemClass: [{ type: Input }],\n    dropZone: [{ type: Input }],\n    dropZones: [{ type: Input }],\n    moves: [{ type: Input }],\n    templateInput: [{ type: Input, args: ['template',] }],\n    templateChild: [{ type: ContentChild, args: [TemplateRef, { static: true },] }],\n    droppable: [{ type: ViewChild, args: [DroppableDirective, { static: true },] }],\n    drop: [{ type: Output }],\n    drag: [{ type: Output }],\n    over: [{ type: Output }],\n    out: [{ type: Output }],\n    remove: [{ type: Output }],\n    cancel: [{ type: Output }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContainerComponent, [{\n        type: Component,\n        args: [{\n                selector: 'ngx-dnd-container',\n                template: \"<div\\n  ngxDroppable\\n  [dropZone]=\\\"dropZone\\\"\\n  [model]=\\\"model\\\"\\n  [copy]=\\\"copy\\\"\\n  [ngClass]=\\\"{ 'gu-empty': !model?.length }\\\"\\n  [removeOnSpill]=\\\"removeOnSpill\\\"\\n  class='ngx-dnd-container'>\\n  <ng-container *ngIf=\\\"model\\\">\\n    <ng-container *ngFor=\\\"let item of model\\\">\\n      <ngx-dnd-item\\n        ngxDraggable\\n        [model]=\\\"item\\\"\\n        [dropZone]=\\\"dropZone\\\"\\n        [dropZones]=\\\"dropZones\\\"\\n        [copy]=\\\"copy\\\"\\n        [moves]=\\\"moves\\\"\\n        [removeOnSpill]=\\\"removeOnSpill\\\"\\n        [droppableItemClass]=\\\"droppableItemClass\\\">\\n      </ngx-dnd-item>\\n    </ng-container>\\n  </ng-container>\\n  <ng-content *ngIf=\\\"!model\\\"></ng-content>\\n</div>\\n\",\n                encapsulation: ViewEncapsulation.None,\n                styles: [\".ngx-dnd-container{background-color:hsla(0,0%,100%,.2);border:2px solid red;margin:10px;padding:10px}.ngx-dnd-container.gu-empty{border:2px dotted red}.ngx-dnd-container:nth-child(odd){background-color:rgba(0,0,0,.2)}.ngx-dnd-container .ex-moved{background-color:#e74c3c}.ngx-dnd-container .ex-over{background-color:hsla(0,0%,100%,.3)}.ngx-dnd-container .handle{background-color:rgba(0,0,0,.4);cursor:move;margin-right:5px;padding:0 5px}.no-select{-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.clearfix:after{clear:both;content:\\\" \\\";display:block;height:0}\"]\n            }]\n    }], function () { return []; }, { copy: [{\n            type: Input\n        }], removeOnSpill: [{\n            type: Input\n        }], dropZone: [{\n            type: Input\n        }], drop: [{\n            type: Output\n        }], drag: [{\n            type: Output\n        }], over: [{\n            type: Output\n        }], out: [{\n            type: Output\n        }], remove: [{\n            type: Output\n        }], cancel: [{\n            type: Output\n        }], dropZones: [{\n            type: Input\n        }], templateInput: [{\n            type: Input,\n            args: ['template']\n        }], templateChild: [{\n            type: ContentChild,\n            args: [TemplateRef, { static: true }]\n        }], model: [{\n            type: Input\n        }], droppableItemClass: [{\n            type: Input\n        }], moves: [{\n            type: Input\n        }], droppable: [{\n            type: ViewChild,\n            args: [DroppableDirective, { static: true }]\n        }] }); })();\n\n/**\n * Component that allows nested ngxDroppable and ngxDraggables\n * Should only be use inside a ngx-dnd-container\n * Outside a ngx-dnd-container use ngxDroppable\n *\n * @export\n */\nclass ItemComponent {\n    constructor(container, draggableDirective) {\n        this.container = container;\n        this.draggableDirective = draggableDirective;\n        this._copy = false;\n        this._removeOnSpill = false;\n    }\n    get dropZone() {\n        return this._dropZone || this.container.dropZone;\n    }\n    set dropZone(val) {\n        this._dropZone = val;\n    }\n    get dropZones() {\n        return this._dropZones || this.container.dropZones;\n    }\n    set dropZones(val) {\n        this._dropZones = val;\n    }\n    get droppableItemClass() {\n        return this._droppableItemClass || this.container.droppableItemClass;\n    }\n    set droppableItemClass(val) {\n        this._droppableItemClass = val;\n    }\n    get removeOnSpill() {\n        return typeof this._removeOnSpill === 'boolean' ? this._removeOnSpill : this.container.removeOnSpill;\n    }\n    set removeOnSpill(val) {\n        this._removeOnSpill = val;\n    }\n    get copy() {\n        return typeof this._copy === 'boolean' ? this._copy : this.container.copy;\n    }\n    set copy(val) {\n        this._copy = val;\n    }\n    get hasHandle() {\n        return this.draggableDirective.hasHandle;\n    }\n    get moveDisabled() {\n        return !this.draggableDirective.canMove();\n    }\n    get classString() {\n        const itemClass = typeof this.droppableItemClass === 'function' ? this.droppableItemClass(this.model) : this.droppableItemClass;\n        const classes = ['ngx-dnd-item', itemClass || ''];\n        if (this.moveDisabled) {\n            classes.push('move-disabled');\n        }\n        if (this.hasHandle) {\n            classes.push('has-handle');\n        }\n        return classes.join(' ');\n    }\n    get type() {\n        if (Array.isArray(this.model)) {\n            return 'array';\n        }\n        return typeof this.model;\n    }\n    ngOnInit() {\n        this.data = {\n            model: this.model,\n            type: this.type,\n            dropZone: this.dropZone,\n            template: this.container.template\n        };\n    }\n}\nItemComponent.ɵfac = function ItemComponent_Factory(t) { return new (t || ItemComponent)(ɵngcc0.ɵɵdirectiveInject(ContainerComponent), ɵngcc0.ɵɵdirectiveInject(DraggableDirective)); };\nItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ItemComponent, selectors: [[\"ngx-dnd-item\"]], hostVars: 2, hostBindings: function ItemComponent_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(ctx.classString);\n    } }, inputs: { dropZone: \"dropZone\", dropZones: \"dropZones\", droppableItemClass: \"droppableItemClass\", removeOnSpill: \"removeOnSpill\", copy: \"copy\", model: \"model\" }, decls: 5, vars: 4, consts: [[3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"], [3, \"model\", \"template\", \"dropZone\", \"dropZones\", \"removeOnSpill\", \"droppableItemClass\", \"copy\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"ngx-dnd-content\"], [3, \"model\", \"template\", \"dropZone\", \"dropZones\", \"removeOnSpill\", \"droppableItemClass\", \"copy\", 4, \"ngIf\"], [\"class\", \"ngx-dnd-content\", 4, \"ngIf\"]], template: function ItemComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelementContainerStart(0, 0);\n        ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_container_1_Template, 2, 7, \"ng-container\", 1);\n        ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_container_2_Template, 3, 2, \"ng-container\", 1);\n        ɵngcc0.ɵɵtemplate(3, ItemComponent_ng_container_3_Template, 1, 0, \"ng-container\", 1);\n        ɵngcc0.ɵɵtemplate(4, ItemComponent_ng_container_4_Template, 3, 2, \"ng-container\", 2);\n        ɵngcc0.ɵɵelementContainerEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx.type);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"array\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"object\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"undefined\");\n    } }, directives: [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc1.NgSwitchDefault, ContainerComponent, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [\".ngx-dnd-box,.ngx-dnd-item{background-color:rgba(0,0,0,.2);border:1px solid #add8e6;display:block;margin:10px;padding:10px;transition:opacity .4s ease-in-out}.ngx-dnd-box.has-handle [ngxdraghandle],.ngx-dnd-box.has-handle [ngxDragHandle],.ngx-dnd-box:not(.has-handle):not(.move-disabled),.ngx-dnd-item.has-handle [ngxdraghandle],.ngx-dnd-item.has-handle [ngxDragHandle],.ngx-dnd-item:not(.has-handle):not(.move-disabled){cursor:move;cursor:grab;cursor:-webkit-grab}.ngx-dnd-box .ngx-dnd-content,.ngx-dnd-item .ngx-dnd-content{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}.ngx-dnd-box:hover,.ngx-dnd-item:hover{border:1px solid #00f}.ngx-dnd-box{float:left;height:40px;line-height:20px;text-align:center;width:40px}.gu-mirror{-ms-filter:\\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\\\";filter:alpha(opacity=80);margin:0!important;opacity:.8;position:fixed!important;z-index:9999!important}.gu-hide{display:none!important}.gu-unselectable{-moz-user-select:none!important;-ms-user-select:none!important;-webkit-user-select:none!important;user-select:none!important}.gu-transit{-ms-filter:\\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\\\";filter:alpha(opacity=20);opacity:.2}\"], encapsulation: 2 });\nItemComponent.ctorParameters = () => [\n    { type: ContainerComponent },\n    { type: DraggableDirective }\n];\nItemComponent.propDecorators = {\n    model: [{ type: Input }],\n    dropZone: [{ type: Input }],\n    dropZones: [{ type: Input }],\n    droppableItemClass: [{ type: Input }],\n    removeOnSpill: [{ type: Input }],\n    copy: [{ type: Input }],\n    classString: [{ type: HostBinding, args: ['class',] }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemComponent, [{\n        type: Component,\n        args: [{\n                selector: 'ngx-dnd-item',\n                template: \"<ng-container [ngSwitch]=\\\"type\\\">\\n\\n  <ng-container *ngSwitchCase=\\\"'array'\\\">\\n    <ngx-dnd-container\\n      [model]=\\\"model\\\"\\n      [template]=\\\"container.template\\\"\\n      [dropZone]=\\\"dropZone\\\"\\n      [dropZones]=\\\"dropZones\\\"\\n      [removeOnSpill]=\\\"removeOnSpill\\\"\\n      [droppableItemClass]=\\\"droppableItemClass\\\"\\n      [copy]=\\\"copy\\\">\\n    </ngx-dnd-container>\\n  </ng-container>\\n\\n  <ng-container *ngSwitchCase=\\\"'object'\\\">\\n    <ng-template\\n      *ngIf=\\\"container.template\\\"\\n      [ngTemplateOutlet]=\\\"container.template\\\"\\n      [ngTemplateOutletContext]=\\\"data\\\">\\n    </ng-template>\\n    <ng-container *ngIf=\\\"!container.template\\\">\\n      <div\\n        class=\\\"ngx-dnd-content\\\">\\n        {{model.label}}\\n      </div>\\n      <ngx-dnd-container\\n        *ngIf=\\\"model.children\\\"\\n        [model]=\\\"model.children\\\"\\n        [template]=\\\"container.template\\\"\\n        [dropZone]=\\\"dropZone\\\"\\n        [dropZones]=\\\"dropZones\\\"\\n        [removeOnSpill]=\\\"removeOnSpill\\\"\\n        [droppableItemClass]=\\\"droppableItemClass\\\"\\n        [copy]=\\\"copy\\\">\\n      </ngx-dnd-container>\\n    </ng-container>\\n  </ng-container>\\n\\n  <ng-container *ngSwitchCase=\\\"'undefined'\\\">\\n  </ng-container>\\n\\n  <ng-container *ngSwitchDefault>\\n    <ng-template\\n      *ngIf=\\\"container.template\\\"\\n      [ngTemplateOutlet]=\\\"container.template\\\"\\n      [ngTemplateOutletContext]=\\\"data\\\">\\n    </ng-template>\\n    <div\\n      *ngIf=\\\"!container.template\\\"\\n      class=\\\"ngx-dnd-content\\\">\\n      {{model}}\\n    </div>\\n  </ng-container>\\n\\n</ng-container>\\n\\n\\n\\n\\n\\n\\n\\n\",\n                encapsulation: ViewEncapsulation.None,\n                styles: [\".ngx-dnd-box,.ngx-dnd-item{background-color:rgba(0,0,0,.2);border:1px solid #add8e6;display:block;margin:10px;padding:10px;transition:opacity .4s ease-in-out}.ngx-dnd-box.has-handle [ngxdraghandle],.ngx-dnd-box.has-handle [ngxDragHandle],.ngx-dnd-box:not(.has-handle):not(.move-disabled),.ngx-dnd-item.has-handle [ngxdraghandle],.ngx-dnd-item.has-handle [ngxDragHandle],.ngx-dnd-item:not(.has-handle):not(.move-disabled){cursor:move;cursor:grab;cursor:-webkit-grab}.ngx-dnd-box .ngx-dnd-content,.ngx-dnd-item .ngx-dnd-content{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}.ngx-dnd-box:hover,.ngx-dnd-item:hover{border:1px solid #00f}.ngx-dnd-box{float:left;height:40px;line-height:20px;text-align:center;width:40px}.gu-mirror{-ms-filter:\\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\\\";filter:alpha(opacity=80);margin:0!important;opacity:.8;position:fixed!important;z-index:9999!important}.gu-hide{display:none!important}.gu-unselectable{-moz-user-select:none!important;-ms-user-select:none!important;-webkit-user-select:none!important;user-select:none!important}.gu-transit{-ms-filter:\\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\\\";filter:alpha(opacity=20);opacity:.2}\"]\n            }]\n    }], function () { return [{ type: ContainerComponent }, { type: DraggableDirective }]; }, { dropZone: [{\n            type: Input\n        }], dropZones: [{\n            type: Input\n        }], droppableItemClass: [{\n            type: Input\n        }], removeOnSpill: [{\n            type: Input\n        }], copy: [{\n            type: Input\n        }], classString: [{\n            type: HostBinding,\n            args: ['class']\n        }], model: [{\n            type: Input\n        }] }); })();\n\nconst components = [ContainerComponent, ItemComponent];\nconst directives = [DraggableDirective, DroppableDirective, DragHandleDirective];\nclass NgxDnDModule {\n    static forRoot() {\n        return {\n            ngModule: NgxDnDModule,\n            providers: [DrakeStoreService]\n        };\n    }\n}\nNgxDnDModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxDnDModule });\nNgxDnDModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxDnDModule_Factory(t) { return new (t || NgxDnDModule)(); }, imports: [[CommonModule]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxDnDModule, { declarations: function () { return [ContainerComponent, ItemComponent, DraggableDirective, DroppableDirective, DragHandleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ContainerComponent, ItemComponent, DraggableDirective, DroppableDirective, DragHandleDirective]; } }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxDnDModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                declarations: [...components, ...directives],\n                exports: [...components, ...directives]\n            }]\n    }], null, null); })();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ContainerComponent, DragHandleDirective, DraggableDirective, DrakeStoreService, DroppableDirective, ItemComponent, NgxDnDModule };\n\n//# sourceMappingURL=swimlane-ngx-dnd.js.map","'use strict';\n\nvar atoa = require('atoa');\nvar debounce = require('./debounce');\n\nmodule.exports = function emitter (thing, options) {\n  var opts = options || {};\n  var evt = {};\n  if (thing === undefined) { thing = {}; }\n  thing.on = function (type, fn) {\n    if (!evt[type]) {\n      evt[type] = [fn];\n    } else {\n      evt[type].push(fn);\n    }\n    return thing;\n  };\n  thing.once = function (type, fn) {\n    fn._once = true; // thing.off(fn) still works!\n    thing.on(type, fn);\n    return thing;\n  };\n  thing.off = function (type, fn) {\n    var c = arguments.length;\n    if (c === 1) {\n      delete evt[type];\n    } else if (c === 0) {\n      evt = {};\n    } else {\n      var et = evt[type];\n      if (!et) { return thing; }\n      et.splice(et.indexOf(fn), 1);\n    }\n    return thing;\n  };\n  thing.emit = function () {\n    var args = atoa(arguments);\n    return thing.emitterSnapshot(args.shift()).apply(this, args);\n  };\n  thing.emitterSnapshot = function (type) {\n    var et = (evt[type] || []).slice(0);\n    return function () {\n      var args = atoa(arguments);\n      var ctx = this || thing;\n      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }\n      et.forEach(function emitter (listen) {\n        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }\n        if (listen._once) { thing.off(type, listen); }\n      });\n      return thing;\n    };\n  };\n  return thing;\n};\n","module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }\n","var si = typeof setImmediate === 'function', tick;\nif (si) {\n  tick = function (fn) { setImmediate(fn); };\n} else {\n  tick = function (fn) { setTimeout(fn, 0); };\n}\n\nmodule.exports = tick;","'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula (initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) { o.moves = always; }\n  if (o.accepts === void 0) { o.accepts = always; }\n  if (o.invalid === void 0) { o.invalid = invalidTarget; }\n  if (o.containers === void 0) { o.containers = initialContainers || []; }\n  if (o.isContainer === void 0) { o.isContainer = never; }\n  if (o.copy === void 0) { o.copy = false; }\n  if (o.copySortSource === void 0) { o.copySortSource = false; }\n  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n  if (o.direction === void 0) { o.direction = 'vertical'; }\n  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\n  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n\n  return drake;\n\n  function isContainer (el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements (remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy () {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed (e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab (e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved (e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n    // truthy check fixes #239, equality fixes #207\n    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\n      return;\n    }\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e);\n      var clientY = getCoord('clientY', e);\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart (item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove (item) {\n    return !!canStart(item);\n  }\n\n  function manualStart (item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start (context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget () {\n    return false;\n  }\n\n  function end () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab () {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release (e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop (item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target) && item.parent === target) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function remove () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel (revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function cleanup () {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement (target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget (elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n\n    function accepted () {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag (e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed) ||\n      reference !== item &&\n      reference !== nextEl(item)\n    ) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\n    function over () { if (changed) { moved('over'); } }\n    function out () { if (_lastDropTarget) { moved('out'); } }\n  }\n\n  function spillOver (el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut (el) {\n    if (drake.dragging) { classes.add(el, 'gu-hide'); }\n  }\n\n  function renderMirrorImage () {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage () {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild (dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n\n  function getReference (dropTarget, target, x, y) {\n    var direction = typeof o.direction === 'function' ? o.direction(_item, dropTarget, _source) : o.direction;\n    var horizontal = direction === 'horizontal';\n    var mixed = direction === 'mixed';\n    return (target === dropTarget || mixed) ? outside() : inside();\n\n    function outside () { // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!mixed && !horizontal && (rect.top + rect.height / 2) > y) { return el; }\n        if (mixed && (rect.left + rect.width) > x && (rect.top + rect.height) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside () { // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve (after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy (item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy (el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton (e) {\n  if (e.touches !== void 0) { return e.touches.length; }\n  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) { return e.buttons; }\n  var button = e.button;\n  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n\nfunction getOffset (el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll (scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint (point, x, y) {\n  var p = point || {};\n  var state = p.className;\n  var el;\n  p.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  p.className = state;\n  return el;\n}\n\nfunction never () { return false; }\nfunction always () { return true; }\nfunction getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\nfunction getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\nfunction isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\nfunction isEditable (el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl (el) {\n  return el.nextElementSibling || manually();\n  function manually () {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\n\nfunction getEventHost (e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\nfunction getCoord (coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY' // IE8\n  };\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\n\nmodule.exports = dragula;\n","'use strict';\n\nvar ticky = require('ticky');\n\nmodule.exports = function debounce (fn, args, ctx) {\n  if (!fn) { return; }\n  ticky(function run () {\n    fn.apply(ctx || null, args || []);\n  });\n};\n","'use strict';\n\nvar customEvent = require('custom-event');\nvar eventmap = require('./eventmap');\nvar doc = global.document;\nvar addEvent = addEventEasy;\nvar removeEvent = removeEventEasy;\nvar hardCache = [];\n\nif (!global.addEventListener) {\n  addEvent = addEventHard;\n  removeEvent = removeEventHard;\n}\n\nmodule.exports = {\n  add: addEvent,\n  remove: removeEvent,\n  fabricate: fabricateEvent\n};\n\nfunction addEventEasy (el, type, fn, capturing) {\n  return el.addEventListener(type, fn, capturing);\n}\n\nfunction addEventHard (el, type, fn) {\n  return el.attachEvent('on' + type, wrap(el, type, fn));\n}\n\nfunction removeEventEasy (el, type, fn, capturing) {\n  return el.removeEventListener(type, fn, capturing);\n}\n\nfunction removeEventHard (el, type, fn) {\n  var listener = unwrap(el, type, fn);\n  if (listener) {\n    return el.detachEvent('on' + type, listener);\n  }\n}\n\nfunction fabricateEvent (el, type, model) {\n  var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();\n  if (el.dispatchEvent) {\n    el.dispatchEvent(e);\n  } else {\n    el.fireEvent('on' + type, e);\n  }\n  function makeClassicEvent () {\n    var e;\n    if (doc.createEvent) {\n      e = doc.createEvent('Event');\n      e.initEvent(type, true, true);\n    } else if (doc.createEventObject) {\n      e = doc.createEventObject();\n    }\n    return e;\n  }\n  function makeCustomEvent () {\n    return new customEvent(type, { detail: model });\n  }\n}\n\nfunction wrapperFactory (el, type, fn) {\n  return function wrapper (originalEvent) {\n    var e = originalEvent || global.event;\n    e.target = e.target || e.srcElement;\n    e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };\n    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };\n    e.which = e.which || e.keyCode;\n    fn.call(el, e);\n  };\n}\n\nfunction wrap (el, type, fn) {\n  var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);\n  hardCache.push({\n    wrapper: wrapper,\n    element: el,\n    type: type,\n    fn: fn\n  });\n  return wrapper;\n}\n\nfunction unwrap (el, type, fn) {\n  var i = find(el, type, fn);\n  if (i) {\n    var wrapper = hardCache[i].wrapper;\n    hardCache.splice(i, 1); // free up a tad of memory\n    return wrapper;\n  }\n}\n\nfunction find (el, type, fn) {\n  var i, item;\n  for (i = 0; i < hardCache.length; i++) {\n    item = hardCache[i];\n    if (item.element === el && item.type === type && item.fn === fn) {\n      return i;\n    }\n  }\n}\n","'use strict';\n\nvar eventmap = [];\nvar eventname = '';\nvar ron = /^on/;\n\nfor (eventname in global) {\n  if (ron.test(eventname)) {\n    eventmap.push(eventname.slice(2));\n  }\n}\n\nmodule.exports = eventmap;\n","\nvar NativeCustomEvent = global.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n","'use strict';\n\nvar cache = {};\nvar start = '(?:^|\\\\s)';\nvar end = '(?:\\\\s|$)';\n\nfunction lookupClass (className) {\n  var cached = cache[className];\n  if (cached) {\n    cached.lastIndex = 0;\n  } else {\n    cache[className] = cached = new RegExp(start + className + end, 'g');\n  }\n  return cached;\n}\n\nfunction addClass (el, className) {\n  var current = el.className;\n  if (!current.length) {\n    el.className = className;\n  } else if (!lookupClass(className).test(current)) {\n    el.className += ' ' + className;\n  }\n}\n\nfunction rmClass (el, className) {\n  el.className = el.className.replace(lookupClass(className), ' ').trim();\n}\n\nmodule.exports = {\n  add: addClass,\n  rm: rmClass\n};\n"],"sourceRoot":"webpack:///"}